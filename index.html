<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dot Line – Next Level Example</title>
  <meta name="viewport" content="width=400,user-scalable=no">
  <style>
    body { background:#15151a;margin:0;display:flex;justify-content:center;align-items:center;height:100vh; }
    #container { display:flex; flex-direction:column; align-items:center; }
    #gameCanvas { background: #222; border: 4px solid #333; touch-action:none; }
    #message { color:#fff; font-size:1.2em; margin-top:10px; min-height:36px;}
    #level { color:#fff; font-size:1.1em; margin-bottom:6px;}
    #hintBtn {
      background: #36a2eb;
      color: #fff;
      font-size: 1em;
      border: none;
      border-radius: 5px;
      padding: 7px 18px;
      margin-bottom:8px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #hintBtn:active { background:#2083bb;}
    #progress { color:#fff;padding:2px 0 7px 0;font-size:1em; }
  </style>
</head>
<body>
<div id="container">
  <div id="progress"></div>
  <div id="level"></div>
  <button id="hintBtn">Hint</button>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <div id="message"></div>
</div>
<script>
const W=400, H=600, SIZE=5, CELL=W/SIZE;
const ctx=gameCanvas.getContext('2d');

const LEVEL_LIST = [
  // Level 1
  {
    dots:[
      {x:0,y:4,color:'red'},{x:4,y:4,color:'red'},
      {x:0,y:0,color:'blue'},{x:4,y:0,color:'blue'}
    ],
    solutionPaths:{
      red:[{x:0,y:4},{x:1,y:4},{x:2,y:4},{x:3,y:4},{x:4,y:4}],
      blue:[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0}]
    }
  },
  // Level 2
  {
    dots:[
      {x:0,y:0,color:'orange'},{x:4,y:0,color:'orange'},
      {x:0,y:4,color:'green'},{x:4,y:4,color:'green'}
    ],
    solutionPaths:{
      orange:[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0}],
      green:[{x:0,y:4},{x:1,y:4},{x:2,y:4},{x:3,y:4},{x:4,y:4}]
    }
  }
];

let currentLevel=0, dots=[], solutionPaths={}, userPaths={}, currentColor=null, drawing=false, allowMove=true;
let showHint=false, hintTimeout=null;

function loadLevel(n){
  dots=LEVEL_LIST[n].dots;
  solutionPaths=LEVEL_LIST[n].solutionPaths;
  userPaths={};
  Object.keys(solutionPaths).forEach(c=>userPaths[c]=[]);
  currentColor=null; drawing=false; allowMove=true;
  document.getElementById("level").textContent = "Level "+(n+1);
  document.getElementById("progress").textContent = 'Stage ' + (n+1) + ' of ' + LEVEL_LIST.length;
  document.getElementById("message").textContent = "Connect all the dots!";
  showHint=false;
  if(hintTimeout)clearTimeout(hintTimeout);
  drawBoard();
}

function drawBoard() {
  ctx.clearRect(0,0,W,H);
  ctx.strokeStyle="#444";ctx.lineWidth=2;
  for(let i=0;i<=SIZE;i++){
    ctx.beginPath();ctx.moveTo(0,i*CELL);ctx.lineTo(W,i*CELL);ctx.stroke();
    ctx.beginPath();ctx.moveTo(i*CELL,0);ctx.lineTo(i*CELL,SIZE*CELL);ctx.stroke();
  }
  // Draw hint if needed
  if(showHint) {
    Object.keys(solutionPaths).forEach(color=>{
      let path=solutionPaths[color];
      ctx.save();ctx.globalAlpha=.22;
      ctx.strokeStyle=color;ctx.lineWidth=20;ctx.lineCap='round';
      ctx.beginPath();
      path.forEach((pt,i)=>{
        let cx=pt.x*CELL+CELL/2,cy=pt.y*CELL+CELL/2;
        if(i===0)ctx.moveTo(cx,cy);else ctx.lineTo(cx,cy);
      });ctx.stroke();ctx.restore();
    });
  }
  // Player paths
  Object.keys(userPaths).forEach(color=>{
    let path=userPaths[color];
    if(path.length>1){
      ctx.strokeStyle=color;ctx.lineWidth=14;ctx.lineCap='round';
      ctx.beginPath();
      path.forEach((pt,i)=>{
        let cx=pt.x*CELL+CELL/2,cy=pt.y*CELL+CELL/2;
        if(i==0)ctx.moveTo(cx,cy);else ctx.lineTo(cx,cy);
      });ctx.stroke();
    }
  });
  dots.forEach(d=>{
    let cx=d.x*CELL+CELL/2,cy=d.y*CELL+CELL/2;
    ctx.beginPath();
    ctx.arc(cx,cy,CELL/4,0,2*Math.PI);
    ctx.fillStyle=d.color;
    ctx.shadowColor="#000";ctx.shadowBlur=8;
    ctx.fill();ctx.shadowBlur=0;
    ctx.lineWidth=3;ctx.strokeStyle="#fff";ctx.stroke();
  });
}

function pixelToCell(x,y){return {x:Math.max(0,Math.min(SIZE-1,Math.floor(x/CELL))),y:Math.max(0,Math.min(SIZE-1,Math.floor(y/CELL)))};}
function pointsEqual(a,b){return a&&b&&a.x===b.x&&a.y===b.y;}
function resetPath(color){userPaths[color]=[];drawBoard();}
function handleStart(x,y){
  if(!allowMove)return;
  const cell=pixelToCell(x,y);
  for(let dot of dots){if(dot.x==cell.x&&dot.y==cell.y){
    currentColor=dot.color;
    userPaths[currentColor]=[cell];
    drawing=true;drawBoard();return;
  }}currentColor=null;
}
function handleMove(x,y){
  if(!drawing||!currentColor)return;
  const cell=pixelToCell(x,y);
  let path=userPaths[currentColor];
  let last=path[path.length-1];
  if(pointsEqual(last,cell))return;
  if(Math.abs(cell.x-last.x)+Math.abs(cell.y-last.y)==1){
    let used=false;
    Object.values(userPaths).forEach(plist=>{
      if(plist.slice(0,-1).some(pt=>pt.x===cell.x&&pt.y===cell.y))used=true;
    });
    if(!used) {
      path.push(cell);drawBoard();
    }
  }
}
function handleEnd(x, y){
  if(!drawing||!currentColor)return;
  const cell=pixelToCell(x,y);
  let dotsForColor=dots.filter(d=>d.color==currentColor);
  let endDot=dotsForColor[1];
  let path=userPaths[currentColor];
  if(cell.x==endDot.x&&cell.y==endDot.y){
    userPaths[currentColor][userPaths[currentColor].length-1]={x:endDot.x,y:endDot.y};
    drawBoard();checkWin();
  }else{
    message.textContent="Try again: connect to matching dot!";
    setTimeout(()=>{message.textContent="";},1300);
    resetPath(currentColor);}
  drawing=false;currentColor=null;
}

function checkWin(){
  let win=true;
  Object.keys(userPaths).forEach(color=>{
    let path=userPaths[color],sol=solutionPaths[color];
    if(path.length!==sol.length)win=false;
    for(let i=0;i<sol.length;i++){
      if(!path[i]||path[i].x!==sol[i].x||path[i].y!==sol[i].y)win=false;
    }
  });
  if(win){
    allowMove=false;
    message.textContent="Level Complete! Next stage…";
    setTimeout(()=>{
      showHint=false;
      if(currentLevel<LEVEL_LIST.length-1){
        currentLevel++;
        loadLevel(currentLevel);
      }else{
        message.textContent="Congratulations! All stages complete!";
        document.getElementById("level").textContent="";
        document.getElementById("progress").textContent="";
      }
    },1400);
  }
}

document.getElementById('hintBtn').onclick=function(){
  if(showHint)return;
  showHint=true;
  drawBoard();
  if(hintTimeout)clearTimeout(hintTimeout);
  hintTimeout=setTimeout(function(){showHint=false;drawBoard();}, 2200);
};

// Mouse & touch
gameCanvas.addEventListener('mousedown',function(e){
  e.preventDefault();if(e.button!==0)return;
  const rect=this.getBoundingClientRect();
  handleStart(e.clientX-rect.left,e.clientY-rect.top);
});
gameCanvas.addEventListener('mousemove',function(e){
  if(!drawing)return;
  const rect=this.getBoundingClientRect();
  handleMove(e.clientX-rect.left,e.clientY-rect.top);
});
gameCanvas.addEventListener('mouseup',function(e){
  if(!drawing)return;
  const rect=this.getBoundingClientRect();
  handleEnd(e.clientX-rect.left,e.clientY-rect.top);
});
gameCanvas.addEventListener('mouseleave',function(e){
  if(!drawing)return;
  const rect=this.getBoundingClientRect();
  handleEnd(e.clientX-rect.left,e.clientY-rect.top);
});
gameCanvas.addEventListener('touchstart',function(e){
  e.preventDefault();
  if(e.touches.length>0){
    const rect=this.getBoundingClientRect();
    const touch=e.touches[0];
    handleStart(touch.clientX-rect.left,touch.clientY-rect.top);
  }
});
gameCanvas.addEventListener('touchmove',function(e){
  e.preventDefault();
  if(!drawing)return;
  if(e.touches.length>0){
    const rect=this.getBoundingClientRect();
    const touch=e.touches;
    handleMove(touch.clientX-rect.left,touch.clientY-rect.top);
  }
});
gameCanvas.addEventListener('touchend',function(e){
  e.preventDefault();
  if(!drawing||!currentColor)return;
  let path=userPaths[currentColor];
  let last=path[path.length-1];
  handleEnd(last.x*CELL+CELL/2,last.y*CELL+CELL/2);
});
gameCanvas.addEventListener('contextmenu',function(e){e.preventDefault();});
window.addEventListener('resize',()=>{drawBoard();});
const message=document.getElementById("message");
loadLevel(currentLevel);
</script>
</body>
</html>

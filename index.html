<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dot Line Multi-Level Game With Hint</title>
  <meta name="viewport" content="width=400,user-scalable=no" />
  <style>
    body { background:#15151a; margin:0; display:flex; justify-content:center; align-items:center; height:100vh; }
    #container { display:flex; flex-direction:column; align-items:center;}
    #gameCanvas { background: #222; border: 4px solid #333; touch-action:none;}
    #message { color:#fff; font-size:1.2em; margin-top:10px; min-height:40px;}
    #level { color:#fff; font-size:1.1em; margin-bottom:6px;}
    #hintBtn {
      background: #FA7E1E;
      color: #fff;
      font-size: 1em;
      border: none;
      border-radius: 5px;
      padding: 8px 18px;
      margin-bottom:8px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #hintBtn:active { background:#f58336;}
  </style>
</head>
<body>
<div id="container">
  <div id="level">Level 1</div>
  <button id="hintBtn">Hint</button>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <div id="message">Connect all the dots!</div>
</div>
<script>
const W=400, H=600, SIZE=5, CELL=W/SIZE;
const ctx=gameCanvas.getContext('2d');

// --- Levels setup ---
const levels = [
  // Level 1 - same as your screenshot
  {
    dots: [
      {x:0, y:0, color:'red'},    {x:4, y:4, color:'red'},
      {x:1, y:1, color:'blue'},   {x:4, y:1, color:'blue'},
      {x:2, y:1, color:'green'},  {x:4, y:2, color:'green'},
      {x:1, y:3, color:'orange'},{x:3, y:2, color:'orange'}
    ],
    solutionPaths: {
      red:   [{x:0,y:0},{x:0,y:4},{x:4,y:4}],
      blue:  [{x:1,y:1},{x:4,y:1}],
      green: [{x:2,y:1},{x:2,y:4},{x:4,y:4},{x:4,y:2}],
      orange:[{x:1,y:3},{x:3,y:3},{x:3,y:2}]
    }
  },
  // Level 2 - sample
  {
    dots: [
      {x:0, y:0, color:'red'},   {x:4, y:1, color:'red'},
      {x:1, y:0, color:'green'}, {x:0, y:4, color:'green'},
      {x:1, y:1, color:'blue'},  {x:3, y:3, color:'blue'},
      {x:2, y:3, color:'orange'},{x:4, y:4, color:'orange'}
    ],
    solutionPaths: {
      red:   [{x:0,y:0},{x:1,y:0},{x:4,y:0},{x:4,y:1}],
      green: [{x:1,y:0},{x:1,y:2},{x:0,y:2},{x:0,y:4}],
      blue:  [{x:1,y:1},{x:2,y:1},{x:3,y:1},{x:3,y:3}],
      orange:[{x:2,y:3},{x:4,y:3},{x:4,y:4}]
    }
  }
];

let currentLevel=0;
let dots=[], solutionPaths={}, userPaths={}, currentColor=null, drawing=false, allowMove=true;
let showHint=false, hintTimeout=null;

function loadLevel(n){
  dots=levels[n].dots;
  solutionPaths=levels[n].solutionPaths;
  userPaths={};
  Object.keys(solutionPaths).forEach(c=>userPaths[c]=[]);
  currentColor=null; drawing=false; allowMove=true;
  document.getElementById("level").textContent = "Level "+(n+1);
  document.getElementById("message").textContent = "Connect all the dots!";
  showHint=false; if (hintTimeout) clearTimeout(hintTimeout);
  drawBoard();
}

function drawBoard() {
  ctx.clearRect(0,0,W,H);
  ctx.strokeStyle="#444"; ctx.lineWidth=2;
  for(let i=0;i<=SIZE;i++){
    ctx.beginPath();ctx.moveTo(0,i*CELL);ctx.lineTo(W,i*CELL);ctx.stroke();
    ctx.beginPath();ctx.moveTo(i*CELL,0);ctx.lineTo(i*CELL,SIZE*CELL);ctx.stroke();
  }
  // Draw hint if needed
  if (showHint) {
    Object.keys(solutionPaths).forEach(color => {
      let path = solutionPaths[color];
      ctx.save();
      ctx.globalAlpha = 0.2;
      ctx.strokeStyle = color;
      ctx.lineWidth = 18;
      ctx.beginPath();
      path.forEach((pt,i)=>{
        let cx=pt.x*CELL+CELL/2, cy=pt.y*CELL+CELL/2;
        if(i===0) ctx.moveTo(cx,cy);
        else ctx.lineTo(cx,cy);
      });
      ctx.stroke();
      ctx.restore();
    });
  }
  // User drawn lines
  Object.keys(userPaths).forEach(color=>{
    let path = userPaths[color];
    if(path.length>1){
      ctx.strokeStyle = color; ctx.lineWidth = 14; ctx.lineCap = 'round';
      ctx.beginPath();
      path.forEach((pt,i)=>{
        let cx = pt.x*CELL+CELL/2, cy = pt.y*CELL+CELL/2;
        if(i==0) ctx.moveTo(cx,cy); else ctx.lineTo(cx,cy);
      });
      ctx.stroke();
    }
  });
  dots.forEach(d=>{
    let cx = d.x*CELL+CELL/2, cy = d.y*CELL+CELL/2;
    ctx.beginPath();
    ctx.arc(cx, cy, CELL/4, 0, 2*Math.PI);
    ctx.fillStyle = d.color;
    ctx.shadowColor="#000"; ctx.shadowBlur=8;
    ctx.fill(); ctx.shadowBlur=0; ctx.lineWidth=3; ctx.strokeStyle="#fff"; ctx.stroke();
  });
}

function pixelToCell(x,y){return {x:Math.max(0,Math.min(SIZE-1,Math.floor(x/CELL))),y:Math.max(0,Math.min(SIZE-1,Math.floor(y/CELL)))};}
function pointsEqual(a,b){ return a&&b&&a.x===b.x&&a.y===b.y; }
function resetPath(color){ userPaths[color]=[]; drawBoard(); }
function handleStart(x,y){
  if(!allowMove) return;
  const cell = pixelToCell(x,y);
  for(let dot of dots){
    if(dot.x==cell.x&&dot.y==cell.y){
      currentColor=dot.color;
      userPaths[currentColor]=[cell];
      drawing=true;drawBoard();return;
    }
  } currentColor=null;
}
function handleMove(x,y){
  if(!drawing||!currentColor) return;
  const cell=pixelToCell(x,y);
  let path=userPaths[currentColor];
  let last=path[path.length-1];
  if(pointsEqual(last,cell)) return;
  if(Math.abs(cell.x-last.x)+Math.abs(cell.y-last.y)==1){
    if(!path.some(pt=>pt.x===cell.x&&pt.y===cell.y)){
      path.push(cell);drawBoard();
    }
  }
}
function handleEnd(x, y){
  if(!drawing||!currentColor)return;
  const cell=pixelToCell(x,y);
  let dotsForColor=dots.filter(d=>d.color==currentColor);
  let endDot=dotsForColor[1];
  let path=userPaths[currentColor];
  if(cell.x==endDot.x&&cell.y==endDot.y){
    userPaths[currentColor][userPaths[currentColor].length-1]={x:endDot.x,y:endDot.y};
    drawBoard();checkWin();
  }else{
    message.textContent="Try again: connect to matching dot!";
    setTimeout(()=>{message.textContent="";},1300);
    resetPath(currentColor);
  }
  drawing=false;currentColor=null;
}
function checkWin(){
  let win=true;
  Object.keys(userPaths).forEach(color=>{
    let path=userPaths[color], sol=solutionPaths[color];
    if(path.length!==sol.length) win=false;
    for(let i=0;i<sol.length;i++){
      if(!path[i]||path[i].x!==sol[i].x||path[i].y!==sol[i].y) win=false;
    }
  });
  if (win) {
    allowMove=false;
    message.textContent="Level Complete! Next levelâ€¦";
    setTimeout(()=>{
      showHint=false;
      if(currentLevel<levels.length-1){
        currentLevel++;
        loadLevel(currentLevel);
      }else{
        message.textContent="Congratulations! All levels complete!";
        document.getElementById("level").textContent="";
      }
    },1500);
  }
}

// -- Hint Button Logic --
document.getElementById('hintBtn').onclick = function(){
  if (showHint) return; // Already showing hint
  showHint = true;
  drawBoard();
  // Hide hint after 3 seconds
  if (hintTimeout) clearTimeout(hintTimeout);
  hintTimeout = setTimeout(function(){
    showHint = false;
    drawBoard();
  }, 3000);
};

// Mouse
gameCanvas.addEventListener('mousedown',function(e){
  e.preventDefault();if(e.button!==0)return;
  const rect=this.getBoundingClientRect();
  handleStart(e.clientX-rect.left,e.clientY-rect.top);
});
gameCanvas.addEventListener('mousemove',function(e){
  if(!drawing)return;
  const rect=this.getBoundingClientRect();
  handleMove(e.clientX-rect.left,e.clientY-rect.top);
});
gameCanvas.addEventListener('mouseup',function(e){
  if(!drawing)return;
  const rect=this.getBoundingClientRect();
  handleEnd(e.clientX-rect.left,e.clientY-rect.top);
});
gameCanvas.addEventListener('mouseleave',function(e){
  if(!drawing)return;
  const rect=this.getBoundingClientRect();
  handleEnd(e.clientX-rect.left,e.clientY-rect.top);
});
// Touch (mobile)
gameCanvas.addEventListener('touchstart',function(e){
  e.preventDefault();
  if(e.touches.length>0){
    const rect=this.getBoundingClientRect();
    const touch=e.touches[0];
    handleStart(touch.clientX-rect.left,touch.clientY-rect.top);
  }
});
gameCanvas.addEventListener('touchmove',function(e){
  e.preventDefault();
  if(!drawing)return;
  if(e.touches.length>0){
    const rect=this.getBoundingClientRect();
    const touch=e.touches;
    handleMove(touch.clientX-rect.left,touch.clientY-rect.top);
  }
});
gameCanvas.addEventListener('touchend',function(e){
  e.preventDefault();
  if(!drawing||!currentColor) return;
  let path=userPaths[currentColor];
  let last=path[path.length-1];
  handleEnd(last.x*CELL+CELL/2,last.y*CELL+CELL/2);
});
gameCanvas.addEventListener('contextmenu',function(e){e.preventDefault();});
window.addEventListener('resize',()=>{drawBoard();});
const message=document.getElementById("message");
loadLevel(currentLevel);
</script>
</body>
</html>
